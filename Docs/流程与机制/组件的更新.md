# 组件的更新

React 提供了俩个方法用于组件的更新。

## setState

* 永远只使用这个方法来改变 state，应该把`this.state`当作是不可变的。
* 不保证`this.state`立马更新生效。
* 不保证`setState`是同步的。
* `setState`的回调函数会在 receiveProps 之后 shouldComponentUpdate 之前调用。

```js
/**
 * @param {object|function} partialState 函数或者state
 * @param {?function} callback 回调函数
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function(partialState, callback) {
    this.updater.enqueueSetState(this, partialState);
    if (callback) {
        this.updater.enqueueCallback(this, callback, "setState");
    }
};
```

### enqueueSetState

```js
/**
 * Sets a subset of the state. This only exists because _pendingState is
 * internal. This provides a merging strategy that is not available to deep
 * properties which is confusing. TODO: Expose pendingState or don't use it
 * during the merge.
 *
 * @param {ReactClass} publicInstance 当前组件实例
 * @param {object} partialState 要合并的state
 * @internal
 */
enqueueSetState = function(publicInstance, partialState) {
    // 从ReactInstanceMap取出{publicInstance: this}
    var internalInstance = getInternalInstanceReadyForUpdate(
        publicInstance,
        "setState"
    );

    // internalInstance为null直接返回
    if (!internalInstance) {
        return;
    }

    // 如果实例的_pendingStateQueue为空,则创建它
    var queue =
        internalInstance._pendingStateQueue ||
        (internalInstance._pendingStateQueue = []);

    //将partialState推入_pendingStateQueue
    queue.push(partialState);

    // 调用ReactUpdates.enqueueUpdate();
    enqueueUpdate(internalInstance);
};
```

## forceUpdate

强制更新。

当 state 层级较深，state 发生改变但是未调用`setState`的情况下使用。

这个方法不会触发`shouldComponentUpdate`，但是会触发 `componentWillUpdate` 和 `componentDidUpdate`。

```js
/**
 * @param {?function} callback 回调
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function(callback) {
    this.updater.enqueueForceUpdate(this);
    if (callback) {
        this.updater.enqueueCallback(this, callback, "forceUpdate");
    }
};
```

### enqueueForceUpdate

```js
/**
 *
 * @param {ReactClass} publicInstance 当前组件实例
 * @internal
 */
enqueueForceUpdate = function(publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(
        publicInstance,
        "forceUpdate"
    );

    if (!internalInstance) {
        return;
    }

    // 将_pendingForceUpdate置为true
    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
};
```


#### enqueueUpdate

```js
/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
    ensureInjected();

    // 如果不是正处于创建或更新组件阶段,则处理update事务
    if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component);
        return;
    }

    // 如果正在创建或更新组件,则暂且先不处理update,只是将组件放在dirtyComponents数组中
    dirtyComponents.push(component);
    if (component._updateBatchNumber == null) {
        component._updateBatchNumber = updateBatchNumber + 1;
    }
}
```


##### batchedUpdates
<!-- enqueueUpdate -->

这个函数会判断当前是否出于更新状态，如果处理则再调用enqueueUpdate，如果不处于更新状态，则进行更新操作。
更新操作会将更新状态置为false；

```js
/**
 * Call the provided function in a context within which calls to `setState`
 * and friends are batched such that components aren't updated unnecessarily.
 */
batchedUpdates = function(callback, a, b, c, d, e) {
    // 获取当前的isBatchingUpdates值
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    // 将isBatchingUpdates设为true，表明正在更新
    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    if (alreadyBatchingUpdates) {
        return callback(a, b, c, d, e);
    } else {
        // 执行更新
        return transaction.perform(callback, null, a, b, c, d, e);
    }
};
```

transaction 详见[Transaction]()

最后通过transaction的方式，执行更新。

