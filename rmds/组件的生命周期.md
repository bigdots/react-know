# 组件的生命周期

`React` 会在组件最终挂载的时候处理组件的生命周期函数。这点已经在[组件的挂载]()中提及，它会在`_renderNewRootComponent`函数中调用`batchedUpdates`方法来实现生命周期。

 <!-- ReactUpdates.js -->

```js
var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap,
};
```


```js
function batchedUpdates(callback, a, b, c, d, e) {
//   ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}
```


```js
/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(
    componentInstance,
    container,
    shouldReuseMarkup,
    context
) {
    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
        /* useCreateElement */
        !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement
    );
    transaction.perform(
        mountComponentIntoNode,
        null,
        componentInstance,
        container,
        transaction,
        shouldReuseMarkup,
        context
    );
    ReactUpdates.ReactReconcileTransaction.release(transaction);
}
```


```js
perform : function(method, scope, a, b, c, d, e, f) {
    var errorThrown;
    var ret;
    try {
        this._isInTransaction = true;
        errorThrown = true;
        // 运行所有wrapper中的initialize方法
        this.initializeAll(0);
        // 执行perform方法传入的callback
        ret = method.call(scope, a, b, c, d, e, f);
        errorThrown = false;
    } finally {
        try {
            if (errorThrown) {
                try {
                    //运行wrapper中的所有close方法
                    this.closeAll(0);
                } catch (err) {}
            } else {
                this.closeAll(0);
            }
        } finally {
            this._isInTransaction = false;
        }
    }
    return ret;
};
```
