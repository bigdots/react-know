# 组件的挂载

在应用组件创建成功后，会调用`React.render`函数将组件进行挂载，渲染到页面中，它的流程如下：

1. instantiateReactComponent()，根据ReactElement的type分别创建ReactDOMComponent， ReactCompositeComponent，ReactDOMTextComponent等对象

2. mountComponent(), 调用React生命周期方法解析组件，得到它的HTML。

3. _mountImageIntoNode(), 将HTML插入到DOM父节点中，通过设置DOM父节点的innerHTML属性。

4. 缓存节点在React中的对应对象，即Virtual DOM。


## React.render

```js
/**
 * nextElement ReactElement
 * container 容器真实DOM
 * callback 回调函数
 **/
render: function(nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(
      null,
      nextElement,
      container,
      callback,
    );
}


ReactMount._renderSubtreeIntoContainer = function(
    parentComponent,
    nextElement,
    container,
    callback
) {
    //  TopLevelWrapper是一个构造函数，this.rootID唯一
    //  封装ReactElement，将nextElement挂载到wrapper的props属性下
    var nextWrappedElement = React.createElement(TopLevelWrapper, {
        child: nextElement
    });

    // 对于ReactDOM.render()调用，parentComponent为null
    var nextContext;
    if (parentComponent) {
        var parentInst = ReactInstanceMap.get(parentComponent);
        nextContext = parentInst._processChildContext(parentInst._context);
    } else {
        nextContext = emptyObject;
    }

    // 获取要插入到的容器的前一次的ReactComponent，这是为了做DOM diff
    // 对于ReactDOM.render()调用，prevComponent为null
    var prevComponent = getTopLevelWrapperInContainer(container);
    if (prevComponent) {
        // 从prevComponent中获取到prevElement这个数据对象
        var prevWrappedElement = prevComponent._currentElement;
        var prevElement = prevWrappedElement.props.child;

        // shouldUpdateReactComponent做diff运算，判断组件是更新还是卸载后重新挂载
        if (shouldUpdateReactComponent(prevElement, nextElement)) {
            var publicInst = prevComponent._renderedComponent.getPublicInstance();
            var updatedCallback =
                callback &&
                function() {
                    callback.call(publicInst);
                };
            // 只需要update，调用_updateRootComponent，然后直接return了
            ReactMount._updateRootComponent(
                prevComponent,
                nextWrappedElement,
                nextContext,
                container,
                updatedCallback
            );
            return publicInst;
        } else {
            // 不做update，直接先卸载再挂载。即unmountComponent,再mountComponent mountComponent在后面代码中进行
            ReactMount.unmountComponentAtNode(container);
        }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup =
        reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    var shouldReuseMarkup =
        containerHasReactMarkup &&
        !prevComponent &&
        !containerHasNonRootReactChild;

    //将ReactElement元素，转化为DOM元素并且插入到对应的Container元素中去；
    var component = ReactMount._renderNewRootComponent(
        nextWrappedElement,
        container,
        shouldReuseMarkup,
        nextContext
    )._renderedComponent.getPublicInstance();

    // 调用callback
    if (callback) {
        callback.call(component);
    }
    return component;
};
```
### 1. 获取nextContext


### 1. 获取前一次挂载的组件`prevComponent`

获取前一次挂载的组件`prevComponent`，如果第一次挂载则`prevComponent`为`null`

### 2. 如果`prevComponent`存在，则做`diff`运算

- 更新组件： 调用`ReactMount._updateRootComponent`更新组件
- 替换组件： 调用`ReactMount.unmountComponentAtNode`销毁组件

### 3. 调用`_renderNewRootComponent`方法

```js
    _renderNewRootComponent: function(
        nextElement,
        container,
        shouldReuseMarkup,
        context,
    ) {

        ReactBrowserEventEmitter.ensureScrollValueMonitoring();

        // 根据ReactElement中不同的type字段，创建不同类型的组件对象。
        var componentInstance = instantiateReactComponent(nextElement, false);

        // 处理batchedMountComponentIntoNode方法调用，将ReactComponent插入DOM中，
        ReactUpdates.batchedUpdates(
        batchedMountComponentIntoNode,
        componentInstance,
        container,
        shouldReuseMarkup,
        context,
        );

        var wrapperID = componentInstance._instance.rootID;
        instancesByReactRootID[wrapperID] = componentInstance;

        return componentInstance;
    }
```

- 调用`instantiateReactComponent`方法创建不同类型的组件对象
- 调用`batchedUpdates`方法,实现生命周期,详见[生命周期]()
- 返回`componentInstance`
### 4. 调用 `callback`

### 5. 返回当前`component`





